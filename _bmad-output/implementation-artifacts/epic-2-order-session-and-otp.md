# Epic 2: Order Initiation & OTP

> **⚠️ Epic Numbering Note**: This supplemental file was numbered from the securities-order domain and corresponds to **Epic 4 in epics.md: Channel Order Session & OTP FSM**. The canonical story authority is always `_bmad-output/planning-artifacts/epics.md`.


## Summary

An authenticated user can initiate a securities order (BUY/SELL) creating an OrderSession in `PENDING_NEW` state, complete TOTP step-up authentication, and advance the session to `AUTHED` state. Insufficient cash (BUY), insufficient position qty (SELL), daily sell limit exceeded, OTP expiry, and duplicate attempts are all handled safely.

**FRs covered:** FR-11, FR-12, FR-13, FR-14, FR-15, FR-16, FR-17, FR-18, FR-47, FR-49  
**Architecture requirements:** OrderSessionService.initiate() (cash/position/daily-limit validation), OtpService, OrderSession FSM (PENDING_NEW→AUTHED), TOTP (RFC 6238, ±1 window, Vault-stored secret), clOrdID UNIQUE  
**Frontend:** OrderPage.tsx (FSM), OrderInputForm.tsx, OtpInput.tsx, useOrder.ts (useReducer)

> **OrderSession FSM (Backend):** `PENDING_NEW → AUTHED → EXECUTING → COMPLETED | FAILED | EXPIRED`  
> **Frontend useReducer step FSM:** `'INPUT' → 'OTP' → 'CONFIRM' → 'PROCESSING' → 'COMPLETED' | 'FAILED' | 'OTP_EXPIRED'`
>
> **Redis keys:**
> - `ch:order-session:{sessionId}` (TTL 600s)
> - `ch:totp-used:{memberId}:{windowIndex}:{code}` (TTL 60s — replay prevention)
> - `ch:otp-attempts:{sessionId}` (TTL per-session count)
> - `ch:otp-attempt-ts:{sessionId}` (TTL 1s debounce)
>
> **TOTP Secret storage:** Vault `secret/fix/member/{memberId}/totp-secret` (FR-TOTP-04 — DB storage absolutely prohibited)

---

## Story 2.1: Order Session Initiation & Status API

As an **authenticated user**,  
I want to initiate an order session specifying stock symbol, side (BUY/SELL), quantity, and price,  
So that I can proceed through the OTP verification step before the order is executed.

**Depends On:** Story 1.4 (portfolio inquiry API), Story 1.2 (Spring Session authentication)

### Acceptance Criteria

**Given** `POST /api/v1/orders/sessions` with `{ symbol, side, qty, price, clOrdID }` (valid JSESSIONID cookie)  
**When** `OrderSessionService.initiate()` executes  
**Then** `clOrdID` is **generated by the client using `crypto.randomUUID()`** and sent  
**And** `side` ∈ `{ "BUY", "SELL" }` validated (HTTP 400 `ORD-004` if invalid)  
**And** `symbol` non-empty 6-digit KRX code validated (HTTP 400 `ORD-004` if blank/malformed)  
**And** `qty` > 0 validated (HTTP 400 `ORD-004` if 0 or below)  
**And** `price` > 0 validated (HTTP 400 `ORD-004` if 0 or below)  
**And** TOTP not registered check: `member.totp_enabled = false` → HTTP 403 `{ code: "AUTH-009", message: "Google OTP registration is required.", enrollUrl: "/settings/totp/enroll" }` (FR-TOTP-02)

**Given** BUY order submitted  
**When** cash balance validation  
**Then** corebank-service `GET /internal/v1/accounts/{accountId}/cash` called for real-time available cash  
**And** `qty × price > availableCash` → HTTP 422 `{ code: "ORD-001", message: "Insufficient cash.", availableCash: N, requiredAmount: M }` (FR-49)

**Given** SELL order submitted  
**When** position and daily limit validation  
**Then** corebank-service `GET /internal/v1/accounts/{accountId}/positions?symbol={symbol}` called for real-time available qty  
**And** `qty > available_qty` → HTTP 422 `{ code: "ORD-003", message: "Insufficient position qty.", availableQty: N, requestedQty: M }` (FR-49)  
**And** QueryDSL daily sell limit query executed: `SUM(order_executions.executed_qty WHERE side=SELL AND symbol=X AND account_id=Y AND created_at >= today)`  
**And** `todaySold + qty > Account.dailySellLimit` → HTTP 422 `{ code: "ORD-002", message: "Daily sell limit exceeded.", todaySold: N, dailyLimit: M, requestedQty: Q }` (FR-47)  
**And** `Account.dailySellLimit` default per-symbol (externalized via env var `DAILY_SELL_LIMIT_DEFAULT`)

**Given** validation passes (BUY or SELL)  
**When** `OrderSessionService.initiate()` continues  
**Then** create `OrderSession` (status: `PENDING_NEW`, sessionId: UUID, symbol, side, qty, price, clOrdID UNIQUE INDEX)  
**And** Redis `ch:order-session:{sessionId}` TTL 600s stored  
**And** Redis `ch:otp-attempts:{sessionId}` initialized to `3` (SET NX EX 600) — consumed by Story 2.2 TOTP verification  
**And** HTTP 201: `{ sessionId, status: "PENDING_NEW", symbol, side, qty, price, expiresAt }`

**Given** re-request with same `clOrdID` (same member)  
**When** UNIQUE INDEX conflict detected  
**Then** HTTP 200: existing `OrderSession` response returned (no re-execution, FR-22)

**Given** request with same value as `clOrdID` owned by **another member**  
**When** UNIQUE INDEX conflict + ownership verification fails (memberId mismatch)  
**Then** HTTP 403 `{ code: "AUTH-007", message: "Access denied." }`

**Given** `GET /api/v1/orders/sessions/{sessionId}/status` (valid JSESSIONID cookie)  
**When** ownership confirmed via `SessionOwnershipValidator`  
**Then** HTTP 200: `SessionStatusResponse` — includes status-specific optional fields (null fields excluded via Jackson `NON_NULL` setting):
```json
{
  "sessionId": "uuid",
  "status": "COMPLETED",
  "symbol": "005930",
  "side": "BUY",
  "qty": 60,
  "price": 75000,
  "remainingSeconds": null,
  "orderId": "fix-ord-20260225-a1b2c3",
  "executedQty": 60,
  "executedPrice": 75000,
  "positionQty": 60,
  "failureReason": null,
  "createdAt": "2026-02-24T10:00:00Z"
}
```
**And** `remainingSeconds`: included only in `PENDING_NEW`/`AUTHED` status (Redis TTL-based calculation)  
**And** `orderId`: included only in `COMPLETED`/`FAILED` status (FR-25)  
**And** `executedQty`, `executedPrice`, `positionQty`: included only in `COMPLETED` status (FR-48)  
**And** `failureReason`: included only in `FAILED` status (`INSUFFICIENT_CASH`/`INSUFFICIENT_POSITION`/`FEP_ERROR`/`INTERNAL_ERROR`, FR-54)

**Given** `SessionStatusResponse` OpenAPI schema contract locked  
**When** Story 2.1 PR merged  
**Then** `SessionStatusResponse` schema explicitly defined with SpringDoc `@Schema` annotations  
**And** `GET /swagger-ui.html` → response model for the endpoint visible

**Given** Package Structure  
**Then** Package Path `io.github.yeongjae.fix.channel.order.{subpackage}`:
- `domain/OrderSession.java` — `@Entity`, FSM status enum (`PENDING_NEW`, `AUTHED`, `EXECUTING`, `COMPLETED`, `FAILED`, `EXPIRED`)
- `service/OrderSessionService.java` — `initiate()`, `getStatus()`
- `service/OtpService.java` — `generate()`, `verify()`
- `service/SessionOwnershipValidator.java` — `@Component`, `validateOwner(sessionId, memberId)`
- `controller/OrderController.java` — POST /api/v1/orders/sessions, GET /api/v1/orders/sessions/{id}/status
- `controller/OtpController.java` — POST /api/v1/orders/sessions/{id}/otp/verify

**Given** non-existent or expired sessionId queried  
**When** no Redis key  
**Then** HTTP 404 `{ code: "ORD-005", message: "Order session not found." }`

**Given** `ChannelIntegrationTestBase` (Testcontainers MySQL + Redis)  
**When** order session creation integration test runs  
**Then** BUY insufficient cash, SELL insufficient position, SELL daily sell limit exceeded, duplicate clOrdID, and successful creation cases all pass  
**And** Redis TTL verified as set within exactly 600s

---

## Story 2.2: TOTP Step-Up Verification

As an **authenticated user with a pending order session**,  
I want to enter my Google Authenticator code to advance the session to AUTHED state,  
So that my order completes step-up authentication before execution.

**Depends On:** Story 2.1, Story 1.8

### Acceptance Criteria

**Given** `POST /api/v1/orders/sessions/{sessionId}/otp/verify` with `{ totpCode: "123456" }`  
**When** TOTP verification (session status: `PENDING_NEW`)  
**Then** Session ownership verification via `SessionOwnershipValidator`  
**And** RULE-015 debounce applied: `SET ch:otp-attempt-ts:{sessionId} NX EX 1` → if key exists HTTP 429 `{ code: "RATE-001", message: "Too many requests. Please wait 1 second." }` (no attempt consumption)  
**And** Vault `secret/fix/member/{memberId}/totp-secret` lookup → `TotpOtpService.verify(sessionId, totpCode, memberId)` execution  
**And** RFC 6238 ±1 window allowed (windowIndex = epochSeconds / 30, ±1 range sequential verification):
```java
long windowIndex = clock.instant().getEpochSecond() / 30;
for (long w = windowIndex - 1; w <= windowIndex + 1; w++) {
    if (totpMatches(vaultSecret, w, totpCode)) { /* match */ }
}
```
**And** Replay prevention: `ch:totp-used:{memberId}:{windowIndex}:{code}` `SETNX TTL 60s` — reuse of same code in same window → HTTP 401 `{ code: "AUTH-011", message: "Authentication code already used." }`  
**And** Verification success → session status changed to `AUTHED`  
**And** HTTP 200: `{ sessionId, status: "AUTHED", message: "Authentication complete." }`

**Given** Incorrect TOTP code entry (±1 window mismatch)  
**When** TOTP mismatch  
**Then** `ch:otp-attempts:{sessionId}` DECR executed atomically  
**And** HTTP 401 `{ code: "AUTH-004", remainingAttempts: N }` (N > 0)  
**And** remainingAttempts == 0 → session status `FAILED`, HTTP 401 `{ code: "AUTH-005", message: "Maximum authentication attempts exceeded. Please restart the order." }` (FR-16)

**Given** Verify request when session status is not `PENDING_NEW`  
**When** FSM state validation failure  
**Then** HTTP response based on status:
- `AUTHED` → HTTP 409 `{ code: "ORD-005", message: "Session already authenticated. Proceed to execute.", currentStatus: "AUTHED" }` (not a terminal state; OTP step already passed)
- `EXECUTING` → HTTP 409 `{ code: "ORD-005", message: "Order execution in progress.", currentStatus: "EXECUTING" }` (not a terminal state; cannot re-verify)
- `COMPLETED`/`FAILED` → HTTP 409 `{ code: "ORD-006", message: "Order session ended." }` (terminal state)
- `EXPIRED` → HTTP 404 `{ code: "ORD-005", message: "Order session not found." }` (TTL 만료, 모든 트리거 비 코드 동일)

**Given** `verify` request after session TTL (600s) expiry  
**When** `ch:order-session:{sessionId}` key missing  
**Then** HTTP 404 `{ code: "ORD-005" }`

**Given** Two concurrent OTP verify requests for same session (both valid)  
**When** Both requests enter `TotpOtpService.verify()` simultaneously  
**Then** Exactly 1 request returns HTTP 200 `AUTHED`  
**And** The other returns HTTP 409 `{ code: "CORE-003", message: "Session already processing.", currentStatus: "AUTHED" }`  
**And** Optimistic Lock collision detected at DB level via `@Version Long version` in `OrderSession` entity

**Given** `TotpOtpService` design  
**Then** `OtpService` interface:
```java
public interface OtpService {
    TotpEnrollResult generateSecret(Long memberId);         // Story 1.8 Enrollment
    boolean confirmEnrollment(Long memberId, String code);  // Story 1.8 Enrollment Verification
    OtpVerifyResult verify(String sessionId, String code, Long memberId); // Story 2.2
}
```
**And** Library: `com.warrenstrange:googleauth:1.5.0`  
**And** Vault Client: `org.springframework.vault:spring-vault-core`

**Given** `TotpSecretRepository` interface extraction (Prerequisite for Vault migration in Story 6.4)  
**When** designing `TotpOtpService`  
**Then** Interface definition:
```java
public interface TotpSecretRepository {
    void save(Long memberId, String base32Secret);
    Optional<String> findByMemberId(Long memberId);
    void deleteByMemberId(Long memberId);
}
```
**And** Default implementation: `DatabaseTotpSecretRepository implements TotpSecretRepository` `@Profile("!vault")` — `@EncryptedColumn` AES-256 DB storage  
**And** `TotpOtpService` references only `TotpSecretRepository` interface

**Given** `DevToolController` (`@Profile("local,dev")`)  
**When** Current TOTP code verification needed in dev/demo environment  
**Then** `GET /api/v1/dev/sessions/{sessionId}/totp-code` → Server-side current code returned  
**And** `@Operation(hidden = true)` — Not exposed in Swagger

**Given** `ChannelIntegrationTestBase` (Real Redis + WireMock Vault)  
**When** TOTP integration test execution  
**Then** Verification success, attempts exceeded, debounce, ±1 window boundary, replay prevention cases all pass

---

## Story 2.3: Frontend — Order Flow FSM (Step A & B)

As a **logged-in user on the Dashboard**,  
I want to initiate a securities order (BUY/SELL) and verify OTP within a modal without page reload,  
So that the order flow feels fast and consistent with Korean HTS (Home Trading System) UX.

**Depends On:** Story 2.1, Story 2.2, Story 1.7

### Acceptance Criteria

**Given** "주문 입력" button clicked on DashboardPage  
**When** `<OrderModal>` renders  
**Then** no URL change (NFR-UX1)  
**And** `useReducer(orderReducer, { step: 'INPUT', clOrdID: crypto.randomUUID(), sessionId: null, symbol: '', side: 'BUY', qty: 0, price: 0 })` initial state  
**And** Step A: symbol (종목코드), side (BUY/SELL radio button), qty (수량), price (단가) input fields displayed

**Given** "Next" button clicked in Step A  
**When** `POST /api/v1/orders/sessions` calling  
**Then** `data-testid="order-next-btn"` disabled + loading spinner displayed

**Given** order session creation success (HTTP 201)  
**When** response received  
**Then** FSM dispatch `{ type: 'SESSION_CREATED', sessionId, expiresAt }` → step transitions to `'OTP'`  
**And** Step B: OTP input screen displayed  
**And** OTP input UI: **6 separate `<input maxLength={1}>` boxes** — `aria-label="Authentication code digit {n}"`  
**And** timer hierarchy:
  - **[Priority 1]** TOTP 30-second window countdown (`data-testid="otp-timer"`) — "{N} seconds until code refresh in Google Authenticator"; red when ≤ 5 seconds
  - **[Priority 2]** session remaining time (`data-testid="session-timer"`) — displayed only when below 60 seconds remaining (session expires at 600s)

**Given** BUY: insufficient cash response (HTTP 422 ORD-001)  
**When** error handled  
**Then** `data-testid="order-error-msg"`: "주문 가능한 현금이 부족합니다. 가용 현금: ₩{availableCash} / 필요 금액: ₩{qty×price}" (role="alert")

**Given** SELL: insufficient position response (HTTP 422 ORD-003)  
**When** error handled  
**Then** `data-testid="order-error-msg"`: "보유 수량이 부족합니다. 매도 가능 수량: {availableQty}주 / 주문 수량: {qty}주" (role="alert")

**Given** SELL: daily sell limit exceeded (HTTP 422 ORD-002)  
**When** error handled  
**Then** `data-testid="order-error-msg"`: "일일 매도 한도를 초과하였습니다. ({symbol} 오늘 매도: {todaySold}주 / 한도: {dailyLimit}주)" (role="alert")

**Given** OTP 6-digit entry completed  
**When** last digit entered  
**Then** automatic `POST /api/v1/orders/sessions/{sessionId}/otp/verify` call (OTP auto-submit)

**Given** OTP verification success (HTTP 200 AUTHED)  
**When** response received  
**Then** FSM dispatch `{ type: 'OTP_VERIFIED' }` → step transitions to `'CONFIRM'` (implemented in Epic 4 Story 4.4)

**Given** TOTP code mismatch or replay prevention (HTTP 401)  
**When** error received  
**Then** red border on each input box + `data-testid="otp-error-msg"`: "Code is incorrect. Remaining attempts: {remainingAttempts}"

**Given** attempts exceeded (HTTP 401 AUTH-005)  
**When** error received  
**Then** "Authentication attempts exceeded. Please restart the order." + [Start over] button

**Given** session expiry detected in `step: 'OTP'` state — Epic 2 temporary polling strategy  
**When** `useEffect` polling activated (10-second interval)  
**Then** `setInterval(() => api.get('/api/v1/orders/sessions/{sessionId}/status'), 10_000)` runs while `step === 'OTP'`  
**And** response `status === 'EXPIRED'` → FSM `dispatch({ type: 'OTP_EXPIRED' })` (maps backend `EXPIRED` to frontend `OTP_EXPIRED` step)  
**And** **this polling replaced with SSE subscription in Epic 5 Story 5.2**

**Given** `step: 'OTP_EXPIRED'` state  
**When** polling detects or frontend countdown reaches 0  
**Then** `data-testid="otp-expired-msg"`: "OTP has expired. Would you like to restart the order?"
