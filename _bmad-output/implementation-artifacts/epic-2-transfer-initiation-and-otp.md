# Epic 2: Transfer Initiation & OTP

## Summary

An authenticated user can initiate a transfer (TransferSession INPUT state), issue OTP, and verify it to advance the session to AUTHED state. Insufficient balance, limit exceeded, OTP expiry, and duplicate attempts are all handled safely.

**FRs covered:** FR-11, FR-12, FR-13, FR-14, FR-15, FR-16, FR-17, FR-18, FR-47, FR-49  
**Architecture requirements:** TransferSessionService.initiate() (including limit validation), OtpService, TransferSession FSM (INPUT→AUTHED), Redis OTP TTL 180s, clientRequestId UNIQUE  
**Frontend:** TransferPage.tsx (FSM), TransferInputForm.tsx, OtpInput.tsx, useTransfer.ts (useReducer)

> **TransferSession FSM:** `INPUT → OTP_PENDING → AUTHED → EXECUTING → COMPLETED | FAILED | EXPIRED`  
> **Redis keys:**
> - `ch:txn-session:{transferSessionId}` (TTL 600s)
> - `ch:totp-used:{memberId}:{windowIndex}:{code}` (TTL 60s — replay prevention)
> - `ch:otp-attempts:{transferSessionId}` (TTL per-session count)
> - `ch:otp-attempt-ts:{transferSessionId}` (TTL 1s debounce)
>
> **TOTP Secret storage:** Vault `secret/fix/member/{memberId}/totp-secret` (FR-TOTP-04 — DB storage absolutely prohibited)

---

## Story 2.1: Transfer Session Initiation & Status API

As an **authenticated user**,  
I want to initiate a transfer session specifying source account, destination account number, and amount,  
So that I can proceed through the OTP verification step before the transfer is executed.

**Depends On:** Story 1.4 (account inquiry API), Story 1.2 (Spring Session authentication)

### Acceptance Criteria

**Given** `POST /api/v1/transfers/sessions` with `{ fromAccountId, toAccountNumber, amount, clientRequestId }` (valid JSESSIONID cookie)  
**When** `TransferSessionService.initiate()` executes  
**Then** `clientRequestId` is **generated by the client using `crypto.randomUUID()`** and sent  
**And** `fromAccountId` ownership verified (HTTP 403 `TRF-006` if not own account) — handled via `SessionOwnershipValidator` common component  
**And** `amount` > 0 validated (HTTP 400 `TRF-001` if 0 or below)  
**And** `toAccountNumber` format validated (`^\d{10,14}$` mismatch → HTTP 400 `TRF-004`)  
**And** same-account transfer blocked (`fromAccount.accountNumber == toAccountNumber` → HTTP 400 `TRF-004`)  
**And** TOTP not registered check: `member.totp_enabled = false` → HTTP 403 `{ code: "AUTH-009", message: "Google OTP registration is required.", enrollUrl: "/settings/totp/enroll" }` (FR-TOTP-02)  
**And** corebank-service `GET /internal/v1/accounts/{accountId}/balance` called for real-time balance  
**And** `amount > availableBalance` → HTTP 422 `{ code: "TRF-002", message: "Insufficient balance.", availableBalance: N, requestedAmount: M }` (FR-49)  
**And** daily cumulative amount query: sum of same-day transfers from same fromAccountId including EXECUTING status (TOCTOU defense)  
**And** cumulative + amount > `Account.dailyLimit` → HTTP 422 `{ code: "TRF-003", message: "Daily transfer limit exceeded.", remainingLimit: N }` (FR-47)  
**And** `Account.dailyLimit` default = **₩5,000,000** (externalized via env var `DAILY_LIMIT_DEFAULT`)  
**And** on validation pass, create `TransferSession` (status: `OTP_PENDING`, sessionId: UUID, clientRequestId UNIQUE INDEX)  
**And** Redis `ch:txn-session:{sessionId}` TTL 600s stored  
**And** HTTP 201: `{ sessionId, status: "OTP_PENDING", fromAccountId, toAccountNumber, amount, expiresAt }`

**Given** re-request with same `clientRequestId` (same member)  
**When** UNIQUE INDEX conflict detected  
**Then** HTTP 200: existing `TransferSession` response returned (no re-execution, FR-22)

**Given** request with same value as `clientRequestId` owned by **another member**  
**When** UNIQUE INDEX conflict + ownership verification fails (memberId mismatch)  
**Then** HTTP 403 `{ code: "TRF-006", message: "Access denied." }`

**Given** `GET /api/v1/transfers/sessions/{sessionId}/status` (valid JSESSIONID cookie)  
**When** ownership confirmed via `SessionOwnershipValidator`  
**Then** HTTP 200: `SessionStatusResponse` — includes status-specific optional fields (null fields excluded via Jackson `NON_NULL` setting):
```json
{
  "sessionId": "uuid",
  "status": "COMPLETED",
  "fromAccountId": 1,
  "toAccountNumber": "110-1234-5678",
  "amount": 100000,
  "remainingSeconds": null,
  "transactionId": "uuid",
  "fromBalance": 900000,
  "failureReason": null,
  "createdAt": "2026-02-24T10:00:00Z"
}
```
**And** `remainingSeconds`: included only in `OTP_PENDING`/`AUTHED` status (Redis TTL-based calculation)  
**And** `transactionId`: included only in `COMPLETED`/`FAILED` status (FR-25)  
**And** `fromBalance`: included only in `COMPLETED` status (FR-48)  
**And** `failureReason`: included only in `FAILED` status (`INSUFFICIENT_BALANCE`/`FEP_ERROR`/`INTERNAL_ERROR`, FR-54)

**Given** `SessionStatusResponse` OpenAPI schema contract locked  
**When** Story 2.1 PR merged  
**Then** `SessionStatusResponse` schema explicitly defined with SpringDoc `@Schema` annotations  
**And** `GET /swagger-ui.html` → response model for the endpoint visible

**Given** Package Structure  
**Then** Package Path `io.github.yeongjae.fix.channel.transfer.{subpackage}`:
- `domain/TransferSession.java` — `@Entity`, FSM status enum
- `service/TransferSessionService.java` — `initiate()`, `getStatus()`
- `service/OtpService.java` — `generate()`, `verify()`
- `service/SessionOwnershipValidator.java` — `@Component`, `validateOwner(sessionId, memberId)`
- `controller/TransferController.java` — POST /sessions, GET /sessions/{id}/status
- `controller/OtpController.java` — POST /sessions/{id}/otp, POST /sessions/{id}/otp/verify

**Given** non-existent or expired sessionId queried  
**When** no Redis key  
**Then** HTTP 404 `{ code: "TRF-008", message: "Transfer session not found." }`

**Given** `ChannelIntegrationTestBase` (Testcontainers MySQL + Redis)  
**When** transfer session creation integration test runs  
**Then** insufficient balance, limit exceeded, duplicate clientRequestId, and successful creation cases all pass  
**And** Redis TTL verified as set within exactly 600s

---

## Story 2.2: TOTP Step-Up Verification

As an **authenticated user with a pending transfer session**,  
I want to enter my Google Authenticator code to advance the session to AUTHED state,  
So that my transfer completes step-up authentication before execution.

**Depends On:** Story 2.1, Story 1.8

### Acceptance Criteria

**Given** `POST /api/v1/transfers/sessions/{sessionId}/otp/verify` with `{ totpCode: "123456" }`  
**When** TOTP verification (session status: `OTP_PENDING`)  
**Then** Session ownership verification via `SessionOwnershipValidator`  
**And** RULE-015 debounce applied: `SET ch:otp-attempt-ts:{sessionId} NX EX 1` → if key exists HTTP 429 `AUTH-004` (no attempt consumption)  
**And** Vault `secret/fix/member/{memberId}/totp-secret` lookup → `TotpOtpService.verify(sessionId, totpCode, memberId)` execution  
**And** RFC 6238 ±1 window allowed (windowIndex = epochSeconds / 30, ±1 range sequential verification):
```java
long windowIndex = clock.instant().getEpochSecond() / 30;
for (long w = windowIndex - 1; w <= windowIndex + 1; w++) {
    if (totpMatches(vaultSecret, w, totpCode)) { /* match */ }
}
```
**And** Replay prevention: `ch:totp-used:{memberId}:{windowIndex}:{code}` `SETNX TTL 60s` — reuse of same code in same window → HTTP 401 `{ code: "AUTH-011", message: "Authentication code already used." }`  
**And** Verification success → session status changed to `AUTHED`  
**And** HTTP 200: `{ sessionId, status: "AUTHED", message: "Authentication complete." }`

**Given** Incorrect TOTP code entry (±1 window mismatch)  
**When** TOTP mismatch  
**Then** `ch:otp-attempts:{sessionId}` DECR executed atomically  
**And** HTTP 401 `{ code: "AUTH-003", remainingAttempts: N }` (N > 0)  
**And** remainingAttempts == 0 → session status `FAILED`, HTTP 401 `{ code: "AUTH-005", message: "Maximum authentication attempts exceeded. Please restart the transfer." }` (FR-16)

**Given** Verify request when session status is not `OTP_PENDING`  
**When** FSM state validation failure  
**Then** HTTP 409 response based on status:
- `AUTHED` → `{ code: "TRF-009", message: "Session already authenticated.", currentStatus: "AUTHED" }`
- `EXECUTING` → `{ code: "TRF-009", message: "Transfer is executing.", currentStatus: "EXECUTING" }`
- `COMPLETED`/`FAILED`/`EXPIRED` → `{ code: "TRF-009", message: "Transfer session ended." }`

**Given** `verify` request after session TTL (600s) expiry  
**When** `ch:txn-session:{sessionId}` key missing  
**Then** HTTP 404 `{ code: "TRF-008" }`

**Given** Two concurrent OTP verify requests for same session (both valid)  
**When** Both requests enter `TotpOtpService.verify()` simultaneously  
**Then** Exactly 1 request returns HTTP 200 `AUTHED`  
**And** The other returns HTTP 409 `{ code: "TRF-009", message: "Session already processing.", currentStatus: "AUTHED" }`  
**And** Optimistic Lock collision detected at DB level via `@Version Long version` in `TransferSession` entity

**Given** `TotpOtpService` design  
**Then** `OtpService` interface:
```java
public interface OtpService {
    TotpEnrollResult generateSecret(Long memberId);         // Story 1.8 Enrollment
    boolean confirmEnrollment(Long memberId, String code);  // Story 1.8 Enrollment Verification
    OtpVerifyResult verify(String sessionId, String code, Long memberId); // Story 2.2
}
```
**And** Library: `com.warrenstrange:googleauth:1.5.0`  
**And** Vault Client: `org.springframework.vault:spring-vault-core`

**Given** `TotpSecretRepository` interface extraction (Prerequisite for Vault migration in Story 6.4)  
**When** designing `TotpOtpService`  
**Then** Interface definition:
```java
public interface TotpSecretRepository {
    void save(Long memberId, String base32Secret);
    Optional<String> findByMemberId(Long memberId);
    void deleteByMemberId(Long memberId);
}
```
**And** Default implementation: `DatabaseTotpSecretRepository implements TotpSecretRepository` `@Profile("!vault")` — `@EncryptedColumn` AES-256 DB storage  
**And** `TotpOtpService` references only `TotpSecretRepository` interface

**Given** `DevToolController` (`@Profile("local,dev")`)  
**When** Current TOTP code verification needed in dev/demo environment  
**Then** `GET /api/v1/dev/sessions/{sessionId}/totp-code` → Server-side current code returned  
**And** `@Operation(hidden = true)` — Not exposed in Swagger

**Given** `ChannelIntegrationTestBase` (Real Redis + WireMock Vault)  
**When** TOTP integration test execution  
**Then** Verification success, attempts exceeded, debounce, ±1 window boundary, replay prevention cases all pass

---

## Story 2.3: Frontend — Transfer Flow FSM (Step A & B)

As a **logged-in user on the Dashboard**,  
I want to initiate a transfer and verify OTP within a modal without page reload,  
So that the transfer flow feels fast and consistent with Korean mobile banking UX.

**Depends On:** Story 2.1, Story 2.2, Story 1.7

### Acceptance Criteria

**Given** account "Transfer" button clicked on DashboardPage  
**When** `<TransferModal>` renders  
**Then** no URL change (NFR-UX1)  
**And** `useReducer(transferReducer, { step: 'INPUT', clientRequestId: crypto.randomUUID(), sessionId: null, ... })` initial state  
**And** Step A: source account, destination account number, transfer amount input fields displayed

**Given** "Next" button clicked in Step A  
**When** `POST /api/v1/transfers/sessions` calling  
**Then** `data-testid="transfer-next-btn"` disabled + loading spinner displayed

**Given** transfer session creation success (HTTP 201)  
**When** response received  
**Then** FSM dispatch `{ type: 'SESSION_CREATED', sessionId, expiresAt }` → step transitions to `'OTP'`  
**And** Step B: OTP input screen displayed  
**And** OTP input UI: **6 separate `<input maxLength={1}>` boxes** — `aria-label="Authentication code digit {n}"`  
**And** timer hierarchy:
  - **[Priority 1]** OTP TTL countdown (`data-testid="otp-countdown"`) — 180s → 0s, red when below 30 seconds
  - **[Priority 2]** TOTP 30-second window countdown (`data-testid="otp-timer"`) — "{N} seconds until app code refresh"
  - **[Priority 3]** session remaining time (`data-testid="session-timer"`) — displayed only when below 60 seconds

**Given** insufficient balance response (HTTP 422 TRF-002)  
**When** error handled  
**Then** `data-testid="transfer-error-msg"`: "Insufficient balance. Source account balance: ₩{availableBalance} / Transfer amount: ₩{amount}" (role="alert")

**Given** OTP 6-digit entry completed  
**When** last digit entered  
**Then** automatic `POST /api/v1/transfers/sessions/{sessionId}/otp/verify` call (OTP auto-submit)

**Given** OTP verification success (HTTP 200 AUTHED)  
**When** response received  
**Then** FSM dispatch `{ type: 'OTP_VERIFIED' }` → step transitions to `'CONFIRM'` (implemented in Epic 4 Story 4.4)

**Given** TOTP code mismatch or replay prevention (HTTP 401)  
**When** error received  
**Then** red border on each input box + `data-testid="otp-error-msg"`: "Code is incorrect. Remaining attempts: {remainingAttempts}"

**Given** attempts exceeded (HTTP 401 AUTH-005)  
**When** error received  
**Then** "Authentication attempts exceeded. Please restart the transfer." + [Start over] button

**Given** OTP expiry detected in `step: 'OTP'` state — Epic 2 temporary polling strategy  
**When** `useEffect` polling activated (10-second interval)  
**Then** `setInterval(() => api.get('/transfers/sessions/{sessionId}/status'), 10_000)` runs while `step === 'OTP'`  
**And** response `status === 'OTP_EXPIRED'` → FSM `dispatch({ type: 'OTP_EXPIRED' })`  
**And** **this polling replaced with SSE subscription in Epic 5 Story 5.2**

**Given** `step: 'OTP_EXPIRED'` state  
**When** polling detects or frontend countdown reaches 0  
**Then** `data-testid="otp-expired-msg"`: "OTP has expired. Would you like to restart the transfer?"  
**And** `data-testid="otp-retry-btn"`: "Restart transfer" button displayed

**Given** TOTP code auto-lookup helper in `import.meta.env.DEV` environment  
**When** developer calls `window.__fixDev.getOtp(sessionId)` in browser console  
**Then** `GET /api/v1/dev/sessions/{sessionId}/totp-code` called → current TOTP code returned  
**And** `fix-web/src/lib/devTools.ts` — `window.__fixDev = { getOtp: async (sessionId: string) => ... }` (production build tree-shaking)
